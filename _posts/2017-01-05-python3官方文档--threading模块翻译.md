---
layout: post
title:  "python3官方文档--threading模块翻译"
date:   2017-01-05 23:37:45
categories: python
tags: python 翻译
author: ZYunH
---

翻译自python-3.5.2-docs中的threading模块部分，原创翻译，转载请注明出处！（翻译进行中，即将完成）


* content
{:toc}



# 17.1 threading-基于线程的并行

------

 这个模块在低级的_thread模块上面构建了一个高级的线程接口。queue模块同样如此。

 dummy_threading模块作用于当threading模块因_thread模块丢失而不能使用时。

------

本模块具有如下函数：

### threading.active_count():

返回当前处于活动状态下的Thread对象数量。返回值的大小等同于enumerate()返回列表的长度。

### threading.current_thread():

返回当前的Thread对象，也同时返回对调用者对线程对象的控制。如果调用者的线程控制不时由threading模块产生，一个被限制功能dummy thread（虚拟线程）对象将会返回。

### threading.get_ident():

返回当前线程的‘线程标志’。这是一个非0的整数，它的值没有直接的意义；它被看作用于索引一个特定线程数据字典的一个魔法糖。线程标志可以被回收，当一个线程退出和另一个线程创建时。

python3.3的新特性。

### threading.enumerate():

返回一个包含所有活动对象的列表。列表包含了由current_thread)_产生的后台的线程、虚拟线程对象，还有一个主线程。它不包括已经结束的进程和没有启动的线程。

### threading.mainthread():

返回主线程对象。一般情况下，主线程就是python解释器启动时的线程。

python3.4的新特性。

### threading.settrace(func):

对所有已经从threading模块启动的线程设置一个追踪函数。func 将会传递到sys.settrace()的每一个线程中，且在每个线程被调用之前传递过去。

### threading.setprofile(func):

对所有已经从threading模块启动的线程设置一个配置函数。func 将会传递到sys.settrace()的每一个线程中，且在每个线程被调用之前传递过去。

### threading.stack_size([size]):

当创建新线程时返回堆栈大小。可选参数size为后来创建的线程指定长度为0的堆栈大小，而且必须为0（使用平台或者参数的预设）或者一个正整数且至少32768（32kib），如果大小尚未指定，预设值0将会被使用。如果改变的堆栈大小是不受支持的，将会引发一个 RuntimeError 错误。如果指定的堆栈大小非法。一个 ValueErroe将会被引发并且堆栈大小将不会被修改。32KiB时，目前最小的可允许的堆栈大小来保持充足的堆栈空间来给解释器使用。注意，一些平台也许会特别限制堆栈的大小，例如需要一个最小的堆栈大小>32KiB或需要分配几倍系统内存页面的大小-引用平台的文档可以得到更多的信息（4KiB页是常见的；在没有更多的特定信息的情况下，推荐使用4096的倍数作为堆栈大小）。可用于：Windows，POSIX的线程系统。

这个模块也定义了一些的常量：

### threading.TIMEOUT_MAX：

阻塞的函数所允许的最大超时时间的值（Lock.acquire(),RLock.acquire(),Condition.wait(),等）如果一个特定的超时时间比这个值大，将会引发一个 OverflowError 错误。

python 3.2的新特性

这个模块定义了一些类，在下面的部分中将会被详细介绍。

# 17.1.1 线程本地数据

线程本地数据是每个线程特有的值。为了管理线程本地数据，只需创建一个local（或者其子集）实例然后将属性存储在其中：

mydata = threading.local()

mydata.x = 1

这个例子中，每个单独的进程的值都将会不同。

### class threading.local：

一个代表线程本地数据的子集。

如果想要了解更多的信息和示例，请查看文档关于_threading_local模块的信息。

# 17.1.2 线程对象

Thread类代表了一种运行在单独线程控制中的活动。有两种方法可以确立这种行为：向构造函数传递一个可以调用的对象，或者在子集中重写run()方法。除此之外，没有其他的方法应该被重写（除了构造函数）。一言以蔽之，在子集中只能重写\__init__()和run()两种方法。

一旦线程对象被创建，只有通过调用线程的start()方法才能使线程对象开始活动。这种做法引入了run()函数作为单独的线程控制。

一旦线程开始活动，线程就被认为处于'alive'（活动）状态。它将一直处于活动状态直到其run()函数的任务被终止，或者更通常的，当引发一个无法控制的错误时线程对象也会被终止。is_alive()函数测试了线程是否处于活动状态。

其他线程可以调用线程的join()方法。这种方法会阻塞线程调用直到那些线程的join()方法被终止为止。

一个线程拥有一个名字。这个名字可以传递给构造函数，也可以通过name属性被读取或者改变。

一个线程可以被标记为“守护线程”（daemon thread）。这种标记的意义时一旦只剩下守护线程，那么整个python程序将会退出。初始的值是从创建的线程中继承的。这个标记可以通过daemon属性或者守护构造函数参数来进行设置。

------

注意：守护线程会突然关闭。它们的资源（例如打开的文件、数据库业务等）可能不会被适当地释放。如果你想让线程优雅地停止，你就需要将它们设置为非守护线程然后运用合适的信号机制例如Event。

------

这里是一个‘主要进程’对象；这相当于python程序在控制初始线程。它不是一个守护进程。

其中有可能‘虚拟线程对象’会被创建。这些对象相当于‘外星线程’（alien threads），这些线程的控制在threading模块之外的地方开始，比如直接从c语言中开始。虚拟对象被限制了功能；它们总是被认为是活动的守护进程，而且不能被join()函数调用。它们永远不会被删除，因为不可能检测到‘外星进程’是否被终止。

### class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)

此构造函数应该永远和关键参数一同被调用。参数有：

**group** 应为None；当一个ThreadGroup被实现时，它预留了未来拓展的功能。

**target** 是一个援引run()方法的可调用对象。默认为None,意味着没有东西被调用。

**name** 是线程的名字。默认情况下，一个唯一的名字将会被构造，结构时"Thread-N",其中N是一个小的十进制数。

**args** 是一个目标调用的元组参数。默认为()。

**kwargs** 是一个目标调用的关键参数字典。默认为()。

如果不为None，daemon就会被显示调用无论是否为后台线程。如果为None（默认），后台的属性是从当前线程继承的。

如果子类重写了构造函数，它在做任何事之前必须引用基本的类构造函数Thread.\__init__.()。

### start()

开始线程的活动。

它至少在每个线程对象被调用一次。它使得了对象的run()方法在单独线程控制中被引用。

这个方法如果在同一线程被调用超过一次时会引发一个RuntimeErroe错误。

### run()

表示线程活动的方法。

你可以在子类中重写此方法。标准的run()方法引用了可调用对象传递至对象的构造函数作为目标参数，如果args和kwargs有顺序、关键的参数，它们将会被分别取出。

### join(timeout=None)

等待直至线程结束。它阻塞线程调用直到那些线程的join()方法被终止为止。即两种情况，遇到一个无法处理的异常，或者等待至可选参数timeout（超时）。

当timeout参数被指定且不为0时，它应是一个以秒为单位指定运行超时时间的浮点数（或者其分数）。join()方法总会返回None，你必须调用is_alive()在join()之后来决定是否有超时事件发生，如果线程仍然活动，那么join()会调用timeout。

当timeout参数未被指定或者为None时，操作将会被阻塞直到线程终止。

一个线程可以被join()调用多次。

join()可以引发一个RuntimeError错误，当尝试加入一个可能导致死锁的当前线程时。当join()调用一个未被启动的线程或者类似的举动也会引发同样的错误。

### name

只用于识别作用的字符串。并没有实际含义。多个线程可能会得到同样的名字。初始的名字由构造函数设置。

### getname()

### setname()

name的旧版本getter/setter接口；可以直接将其视为属性来使用。

### ident

这个线程的“线程标志符”或者当线程未启动时为None。这是一个非0的整数。可参考_thread.get.ident()功能。线程标志符可以被回收当一个线程退出和另一个线程被创建时。标志符在线程退出后依然可以获得。

### is_alive()

返回线程是否处于活动状态。

从run()方法开始直至其结束这段时间，此函数会返回True。这个模块的函数enumerate()返回一个包含所有活动线程的列表。

### daemon

一个布尔值来标志该线程是否为守护线程，True或False。它必须在start()被调用前设置，否则会引发一个RuntimeError。它的初始值时从创建的线程中继承；主线程并非守护线程，因此所有被主线程创建的线程默认都不是守护线程，即daemon = False。

整个python程序在没有非守护线程存在时将会退出。

### isDaemon()

### setDaemon()

Daemon的旧版本getter/setter接口；可以直接将其视为属性来使用。

# 17.1.3 锁对象

原始锁是一个同步原语，当被锁定时，并不属于任何特定线程。在python中，它是目前可用最低级的同步原语，它直接由_thread模块的拓展直接实现。

一个原始锁只有两种状态，即‘locked’（锁定）或者‘unlocked’（非锁定）。它被创建时处于非锁定状态。它有两个基本方法，acquire()和release()，即 得到锁 和 释放锁。当状态为非锁定时，acquire()改变了锁的状态并且立即返回。当状态为锁定时，acquire()将会阻塞直至另一个线程使用release()将锁改变为非锁定状态，然后acquire()调用将锁重置并返回。release()方法应当只在锁定状态被调用；它改变了锁的状态并立即返回。如果尝试将一个非锁定状态的锁释放，那么将会引发一个RuntionError错误。

当不止一个线程被acquire()阻塞并等待锁变为非锁定状态时，只有一个线程将会继续执行当release()调用并重置状态为非锁定；哪一个线程将会继续进行并没有被定义，在实际执行过程中可能会有很大不同。

所有的方法都是原子操作。

### class threading.Lock

这个类实现了原始锁对象。一旦一个线程获得了一个锁，之后的线程尝试获得锁的行为将会被阻塞，直到这个锁被释放；任何线程都可能去释放它。

在python 3.3的变化：由一个工厂函数转变为一个类。

### acquire(blocking=True,timeout=-1)

获得一个阻塞或非阻塞状态的锁。

当被调用时blocking参数被设置为True（默认），将会阻塞直至锁变为非锁定状态，然后将锁设置为锁定状态然后返回True。

当被调用时blocking参数被设置为False，将不会被阻塞。如果一个调用的blocking被设置为True时，它将会被阻塞，并返回立即False；否则，将锁设置为锁定状态时将会返回True。

当被调用时浮点数的timeout参数被设置为一个正数，只要锁不能被获得，那么将会阻塞至少timeout指定的时长。一个timeout参数如果被设置为-1，此时代表一个无条件等待。禁止指定一个timeout参数当blocking为False时。

如果成功获得锁返回值为True，如果不成功则返回False（例如timeout已经到期时）。

在python 3.2的变化：设立timeout参数。

在python 3.2的变化：POSIX的信号可以打断锁的获得。

### release()

释放一个锁。此方法能被任何线程调用，不仅仅只是获得锁的线程。

当锁为锁定状态时，将其重置为非锁定状态，然后返回。如果任何其他的线程被阻塞来等待锁变为非锁定状态，仅允许其中一个可以继续执行。

当在锁处于非锁定状态下被调用时，一个RuntimeError将会被引发。

这个函数将不会返回值。

# 17.1.4 可重用锁对象

一个可重用锁对象是一个同步基元可以被同一个线程获得很多次。在内部，它使用了“拥有线程”和“递归级别”的概念，区别于原始锁所使用的 锁定／非锁定 状态。在锁定状态下，一些线程拥有这个锁；在非锁定状态下，没有线程拥有它。

若要锁上这把锁，一个线程需调用其本身的acquire()方法；一旦这个线程拥有锁它就会将其返回。而解锁这把锁，一个线程需要调用其本身的release()方法。acquire()/release()应该成对嵌套调用。只有位于末尾的release()（即最外层的一对调用中的release()）可以重置锁变为未锁定状态然后允许另一个被阻塞的线程使用acquire()继续执行。

可重用锁也支持context management protocol。

### class threading.RLock

这个类实现了可重用锁对象。一个可重用锁必须被一个获得锁的线程释放。一旦一个线程拥有一个可重用锁，同样的线程可能会再次获得它而不必阻塞；每次线程获得锁后必须将其释放。

注意，Rlock实际上是一个工厂函数，它返回了一个平台支持的最高效率版本的具体类实例。

### acquire(blocking=True,timeout=-1)

获得一个处于锁定状态或非锁定状态的锁。

当以无参数形式被调用时，如果这个线程已经拥有了这把锁，将会逐一增加递归等级，然后立即返回。否则，如果另一个线程拥有这把锁，阻塞直到这把锁变为非锁定状态。一旦锁处于非锁定状态（不属于任何线程），将会抢占所有权，并且设置递归等级为1。如果不止一个线程被阻塞直到锁被释放，在一个时间内只有一个线程可以抢占锁的所有权。这个情况下没有返回值。

当被调用时blocking参数被设置被True，和无参数时情况一样，且返回True。

当被调用时blocking参数被设置为false，将不会阻塞。如果以无参数调用时就会阻塞，立即返回False。否则，和无参数形式调用一样，返回True。

当被调用时将timeout设置为浮点型正值，只要锁不能被获得，那么将会阻塞至少timeout指定的时长。如果锁被获得时返回True，如果超出时间限制则返回false。

Python 3.2的新特性 ：加入了timeout参数。

### release()

释放锁，自减递归锁的等级。如果自减后为0，则重置锁为未锁定状态（不属于任何线程），如果任何其他线程阻塞等待锁变为未锁定状态，允许其中一个继续执行。如果自减后递归等级不为0，则锁依然被锁定，属于调用它的线程。

仅当调用的线程拥有此锁时，才能调用此方法。如果调用此方法时锁处于未锁定状态，就会引发一个RuntimeError错误。

这个方法不会返回值。

# 17.1.5 状态对象

一个状态变量总是关联于一类锁；这可以被传递或默认创建一个。当几个状态变量必须共享一个锁时，传递是有用的方法。锁是状态对象的一部分：你不必分别对待它们。

一个状态变量遵守 context management protocol：使用with声明来获得持续封闭块的关联锁。acquire()和release()方法也调用相应的关联锁方法。

其他方法被调用时必须持有关联锁。wait()方法释放锁，然后阻塞知道另一个线程使用notify()或nitify_all()将其唤醒。一旦被唤醒，wait()将重新获得锁并返回。它也可以指定一个timeout参数。

notify()方法唤醒等待状态变量的线程的其中之一，如果有等待线程的话。notify_all()方法唤醒所有等待状态变量的线程。

注意：notify()和notify_all()并不释放锁；这意味着单一线程或所有线程并不会马上从它们的wait()方法中立即返回，但此时线程调用notify()或者notify_all()会最后放弃锁的所有权。

使用状态变量的典型编程风格是使用锁来实现对某些共享状态的同步访问。线程修改状态调用 notify()或notify_all()时，当他们改变状态使得状态可能符合某一等待线程状态，线程仅关注状态的特定变化，并重复调用wait()直至它们观察到应有的状态为止。例如，下面的代码是一个通用的无限制缓冲能力的producer-consumer问题。

```python
# Consume one item
with cv:
    while not an_item_is_available():
        cv.wait()
    get_an_available()
# Produce one item
with cv:
    make_an_item_available()
    cv.notify()
```

上面的while循环检查了应用情况是必要的。因为wait()可以在一个任意长的时间后返回，这种情况可能会使得notify()调用将不在为true。这是多线程编程所固有的。wait_for()方法可以被用来自动化状态检查，缓解计算超时。

```python
# Consume an item
with cv:
	cv.wait_for(an_item_is_available)
	get_an_avilable_item()
```

notify()和notify_all()的选择，需要考虑是否一种状态的变化能被唯一或者多个等待线程注意到。例如，在经典的producer-consumer问题中，添加一个缓冲项只需要唤醒一个consumer线程。

### class threading.Condition(lock=None)

这个类实现了条件变量对象。一个状态变量允许一个或多个线程等待直到他们被另一个线程唤醒。

如果lock参数被指定并且不为None，它必须是一个Lock或Rlock对象，且被用作底层的锁。否则，一个新的Rlock对象将会被创建并作为底层的锁。

在Python 3.3的改动：将一个工厂函数转变为类。

### acquire(*args)

获得一个底层锁。这个方法调用了底层锁的相应方法；返回的值无论如何就是方法的返回。

### release()

释放一个底层锁。这个方法调用了底层锁的相应方法；但并不返回值。

### wait(timeout=None)

等待知道被唤醒或者timeout发生。当这个方法被调用时，如果调用的线程并没有获得锁，一个RuntimeError错误将会被引发。

这个方法释放了底层锁，然后堵塞，直到notify()或者notify_all()为了在另一线程中的同一状态变量被调用时，将其唤醒，或者直到可选的timeout发生。一旦被唤醒或者timeout，它将重新获得锁并返回。

当timeout参数出现且不为None时，它应该为浮点数，指定的操作timeout为秒（或其分数）。

当底层的锁为Rlock时，使用其自身的release()方法并不会释放，因为这不会真正的解锁当它被递归地多次获得时。而且，Rlock类的一个内部接口将被使用，这个接口将锁解锁，即便其已经被递归获得很多次。当锁获得时，另一个内部接口随后将被用于存储递归等级。

返回值将为True，除非timeout到期，这种情况下将会返回False。

Python 3.2的变化：之前，这个方法始终返回None。

### wait_for(predicate,timeout=None)

等待直至条件计算为True。predicate应被调用，且其结果应该被解析为一个布尔值。一个timeout可以提供一个最大等待时间。

这种实用方法可以不断调用wait()直至predicate被满足，或者直至timeout发生。返回值是predicate的最后返回值，且如果timeout发生，则返回False。

忽略timeout的特性，调用这个方法大致相当于：

```python
while not predicate():
	cv.wait()
```

因此，同样与same()同样的规则：锁必须被持有，当被调用且重新获得并返回时。predicate的计算与锁的持有有关。

Python3.2的新特性。

### notify(n=1)

默认状态下，唤醒一个线程等待这个条件，如果有的话。如果调用此方法时，调用的线程并没有获得锁，会引发一个RuntimeRrror错误。

这个方法唤醒至少n个等待状态变量的线程；如果没有线程处于等待状态，该方法是无效的。
